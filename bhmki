import os
import logging
from typing import TypedDict, Optional, Dict, Any, List
import requests
from langgraph.graph import StateGraph

# --- Logging Setup ---
logging.basicConfig(level=logging.INFO, format='[%(asctime)s] %(levelname)s: %(message)s')

# --- Configuration ---
AGENT_ENDPOINTS = {
    "auth": os.getenv("AUTH_AGENT_URL", "http://localhost:8001"),
    "navigator": os.getenv("NAVIGATOR_AGENT_URL", "http://localhost:8009"),
    "intake": os.getenv("INTAKE_AGENT_URL", "http://localhost:8004"),
    "preprocess": os.getenv("PREPROCESS_AGENT_URL", "http://localhost:8005"),
    "extract": os.getenv("EXTRACTION_AGENT_URL", "http://localhost:8007"),
    "validate": os.getenv("VALIDATION_AGENT_URL", "http://localhost:8002"),
    "sync": os.getenv("SYNC_AGENT_URL", "http://localhost:8003"),
    "feedback": os.getenv("FEEDBACK_AGENT_URL", "http://localhost:8006"),
    "notify": os.getenv("NOTIFY_AGENT_URL", "http://localhost:8008"),
}

# --- Shared State Definition ---
class WorkflowState(TypedDict, total=False):
    user_credentials: Dict[str, Any]
    user: Dict[str, Any]
    id_token: Optional[str]  # Store the Bearer token here
    document: Optional[Dict[str, Any]]
    preprocessed_data: Optional[Any]
    extracted_data: Optional[Dict[str, Any]]
    validation_result: Optional[Dict[str, Any]]
    sync_status: Optional[Dict[str, Any]]
    feedback_data: Optional[Dict[str, Any]]
    notification: Optional[Dict[str, Any]]
    uploaded_files: Optional[List[Any]]
    next_agent: Optional[str]
    user_role: Optional[str]
    doc_type: Optional[str]
    action: Optional[str]
    username: Optional[str]

def close_uploaded_files(files):
    for _, file_tuple in files:
        file_obj = file_tuple[1]
        if hasattr(file_obj, "close"):
            file_obj.close()

def agent_post(endpoint: str, path: str, state: Optional[WorkflowState] = None, **kwargs):
    url = f"{endpoint}{path}"
    headers = kwargs.pop("headers", {})
    if state and "id_token" in state and state["id_token"]:
        headers["Authorization"] = state["id_token"]
    try:
        logging.info(f"POST {url} | Payload: {kwargs.get('json') or kwargs.get('data') or kwargs.get('files')}")
        resp = requests.post(url, headers=headers, **kwargs)
        logging.info(f"Response [{resp.status_code}]: {resp.text}")
        resp.raise_for_status()
        return resp.json()
    except Exception as e:
        logging.error(f"Error calling {url}: {e}")
        raise

def agent_get(endpoint: str, path: str, state: Optional[WorkflowState] = None, **kwargs):
    url = f"{endpoint}{path}"
    headers = kwargs.pop("headers", {})
    if state and "id_token" in state and state["id_token"]:
        headers["Authorization"] = state["id_token"]
    try:
        resp = requests.get(url, headers=headers, **kwargs)
        resp.raise_for_status()
        return resp.json()
    except Exception as e:
        logging.error(f"Error calling {url}: {e}")
        raise

# --- Agent Node Wrappers ---
def auth_agent_node(state: WorkflowState) -> WorkflowState:
    logging.info("Calling AuthAgent")
    payload = state['user_credentials']
    user_info = agent_post(AGENT_ENDPOINTS["auth"], "/login", json=payload)
    state['user'] = user_info
    state['user_role'] = user_info.get("role")
    state['username'] = user_info.get("username")
    # Store token with Bearer prefix for forwarding
    state['id_token'] = f"Bearer {user_info.get('idToken')}"
    return state

def navigator_agent_node(state: WorkflowState) -> WorkflowState:
    logging.info("Calling NavigatorAgent")
    if not state.get("doc_type"):
        raise Exception("doc_type missing in state")
    if not state.get("user_role"):
        raise Exception("user_role missing in state")
    if not state.get("action"):
        # Default action for user role
        state["action"] = "upload" if state["user_role"].lower() == "user" else "review"
    payload = {
        "doc_type": state["doc_type"],
        "user_role": state["user_role"].lower(),
        "action": state["action"].lower()
    }
    result = agent_post(AGENT_ENDPOINTS["navigator"], "/route", state=state, json=payload)
    state['next_agent'] = result.get('next_agent', 'Intake Agent')
    return state

def intake_agent_node(state: WorkflowState) -> WorkflowState:
    if "document" in state and state["document"]:
        # Already uploaded, skip to next step
        return state
    logging.info("Calling IntakeAgent")
    if not state.get("uploaded_file_path"):
        raise Exception("uploaded_file_path missing in state")
    file_path = state["uploaded_file_path"]
    files = [("files", (os.path.basename(file_path), open(file_path, "rb")))]
    data = {
        "document_type": state["doc_type"],
        "username": state["username"]
    }
    try:
        result = agent_post(AGENT_ENDPOINTS["intake"], "/upload_document", state=state, files=files, data=data)
        user_map = agent_get(AGENT_ENDPOINTS["intake"], "/user_map", state=state)
        local_path = None
        for user_files in user_map.get(state["username"], []):
            if user_files["filename"] == os.path.basename(file_path):
                local_path = user_files["local_path"]
                break
        if not local_path:
            raise Exception("Uploaded file not found in user map")
        state['document'] = {
            "file_path": local_path,
            "doc_type": state["doc_type"],
            "metadata": {"username": state["username"], "document_type": state["doc_type"]}
        }
        return state
    finally:
        close_uploaded_files(files)

def preprocess_agent_node(state: WorkflowState) -> WorkflowState:
    logging.info(f"Calling PreprocessAgent for file: {state['document']['file_path']}")
    payload = {"file_path": state["document"]["file_path"]}
    result = agent_post(AGENT_ENDPOINTS["preprocess"], "/preprocess", state=state, json=payload)
    logging.info("Preprocessing complete.")
    return state

def extraction_agent_node(state: WorkflowState) -> WorkflowState:
    original_file_path = state['document']["file_path"]
    logging.info(f"Calling ExtractionAgent for original file: {original_file_path}")
    payload = {"file_paths": [original_file_path], "doc_type": state["doc_type"]}
    result = agent_post(AGENT_ENDPOINTS["extract"], "/extract", state=state, json=payload)
    state['extracted_data'] = result
    return state

def validation_agent_node(state: WorkflowState) -> WorkflowState:
    logging.info("Calling ValidationAgent")
    payload = state["extracted_data"]
    result = agent_post(AGENT_ENDPOINTS["validate"], "/validate", state=state, json=payload)
    state['validation_result'] = result
    return state

def sync_agent_node(state: WorkflowState) -> WorkflowState:
    logging.info("Calling SyncAgent")
    validated_record = {
        "record_id": 1,  # Use unique IDs in production
        "validated_json": state.get("validation_result", {})
    }
    batch = {"records": [validated_record]}
    result = agent_post(AGENT_ENDPOINTS["sync"], "/sync_batch", state=state, json=batch)
    state['sync_status'] = result
    return state

def feedback_agent_node(state: WorkflowState) -> WorkflowState:
    logging.info("Calling FeedbackAgent")
    issue_text = str(state.get("validation_result", {}).get("errors", ""))
    if not issue_text or issue_text == "[]":
        issue_text = state.get("validation_result", {}).get("reason", "Unknown error")
    if not issue_text:
        issue_text = "Validation failed, but no error details were provided."
    payload = {
        "username": state["username"],
        "issue_text": issue_text,
        "rating": 1
    }
    result = agent_post(AGENT_ENDPOINTS["feedback"], "/submit-feedback", state=state, json=payload)
    state['feedback_data'] = result
    return state

def notify_agent_node(state: WorkflowState) -> WorkflowState:
    logging.info("Calling NotifyAgent")
    status_value = state["validation_result"].get("valid")
    if status_value is True:
        status_str = "validated"
    elif status_value is False:
        status_str = "rejected"
    else:
        status_str = str(status_value)
    extracted_text = state["extracted_data"].get("ocr_text", "")
    if not extracted_text:
        extracted_text = state["validation_result"].get("reason", "")
    payload = {
        "document_type": state["doc_type"],
        "status": status_str,
        "extracted_text": extracted_text
    }
    result = agent_post(AGENT_ENDPOINTS["notify"], "/notify", state=state, json=payload)
    state['notification'] = result
    return state

def sync_agent_review_node(state: WorkflowState) -> WorkflowState:
    if state.get('user_role') != 'admin':
        raise Exception("Admin access required for review.")
    logging.info("Calling SyncAgent for Admin Review")
    result = agent_get(AGENT_ENDPOINTS["sync"], "/view_data", state=state)
    state['sync_status'] = result
    return state

# --- LangGraph Orchestration ---
graph = StateGraph(WorkflowState)
graph.add_node("auth", auth_agent_node)
graph.add_node("navigator", navigator_agent_node)
graph.add_node("intake", intake_agent_node)
graph.add_node("preprocess", preprocess_agent_node)
graph.add_node("extract", extraction_agent_node)
graph.add_node("validate", validation_agent_node)
graph.add_node("sync", sync_agent_node)
graph.add_node("sync_review", sync_agent_review_node)
graph.add_node("feedback", feedback_agent_node)
graph.add_node("notify", notify_agent_node)

graph.set_entry_point("auth")
graph.add_edge("auth", "navigator")

def nav_condition(state: WorkflowState):
    agent = state.get("next_agent", "Intake Agent")
    logging.info(f"NavigatorAgent next_agent: {agent}")
    if agent == "Intake Agent":
        return "intake"
    elif agent == "Sync Agent":
        return "sync_review"
    elif agent == "SelectDocument Type":
        logging.error("NavigatorAgent: Document type not selected. Stopping workflow.")
        exit(1)
    else:
        logging.error(f"NavigatorAgent returned unknown next_agent: {agent}. Stopping workflow.")
        exit(1)
graph.add_conditional_edges("navigator", nav_condition)

graph.add_edge("intake", "preprocess")
graph.add_edge("preprocess", "extract")
graph.add_edge("extract", "validate")

def validation_condition(state: WorkflowState):
    if state.get("validation_result", {}).get("valid"):
        return "sync"
    else:
        return "feedback"
graph.add_conditional_edges("validate", validation_condition)

graph.add_edge("sync", "notify")
graph.add_edge("feedback", "notify")
# No further edge from sync_review (admin review is terminal)

workflow = graph.compile()

if __name__ == "__main__":
    logging.info("=== Starting Orchestrator ===")
    initial_state = WorkflowState(
        user_credentials={
            "identifier": input("Enter username/email: "),
            "password": input("Enter password: ")
        }
        # Optionally, you can pre-populate other fields for automation
    )
    try:
        result = workflow.invoke(initial_state)
        logging.info("=== Workflow Complete ===")
        logging.info("Final Workflow State:")
        print(result)
    except Exception as e:
        logging.error(f"=== ERROR in Orchestrator ===\n{str(e)}")
























from fastapi import FastAPI, HTTPException, Request
from pydantic import BaseModel
from typing import Dict, Any, Optional
import logging

# Import your orchestrator workflow and WorkflowState
from orchestrator import workflow, WorkflowState  # Make sure orchestrator.py is in your PYTHONPATH

app = FastAPI(title="Orchestrator Service")

class OrchestratorInput(BaseModel):
    user_credentials: Dict[str, Any]
    doc_type: Optional[str] = None
    action: Optional[str] = None
    uploaded_file_path: Optional[str] = None
    document: Optional[Dict[str, Any]] = None  # <-- add this

    # Add other fields as needed

@app.post("/run_workflow")
async def run_workflow(input_data: OrchestratorInput, request: Request):
    try:
        # Convert input to dict and fill initial state
        initial_state = input_data.dict(exclude_unset=True)
        # Extract the Authorization header (Bearer token)
        auth_header = request.headers.get("Authorization")
        if auth_header and auth_header.startswith("Bearer "):
            initial_state["id_token"] = auth_header  # Keep full "Bearer ..." for agent forwarding
        # Run the orchestrator workflow
        result = workflow.invoke(initial_state)
        return {"status": "success", "result": result}
    except Exception as e:
        logging.error(f"Error running workflow: {e}")
        raise HTTPException(status_code=500, detail=str(e))

















import streamlit as st
import requests
from PIL import Image
import os

# --- CONFIGURATION ---
ORCHESTRATOR_URL = "http://localhost:8000/run_workflow"
AUTH_URL = "http://localhost:8001/login"
SIGNUP_URL = "http://localhost:8001/signup"

st.set_page_config(page_title="Insurance Doc Automation", layout="wide")
st.title("ðŸ“„ Insurance Document Automation Platform")

# --- SESSION STATE ---
if "stage" not in st.session_state: st.session_state.stage = "login"
if "user" not in st.session_state: st.session_state.user = None
if "id_token" not in st.session_state: st.session_state.id_token = None
if "workflow_result" not in st.session_state: st.session_state.workflow_result = None
if "uploaded_file_path" not in st.session_state: st.session_state.uploaded_file_path = None
if "login_password" not in st.session_state: st.session_state.login_password = None

# --- DASHBOARD 1: LOGIN/SIGNUP ---
if st.session_state.stage == "login":
    st.header("User Login / Signup")
    tab1, tab2 = st.tabs(["Login", "Sign Up"])
    with tab1:
        username = st.text_input("Username or Email", key="login_username")
        password = st.text_input("Password", type="password", key="login_password_widget")
        if st.button("Login"):
            payload = {"identifier": username, "password": password}
            resp = requests.post(AUTH_URL, json=payload)
            if resp.ok:
                user_info = resp.json()
                st.session_state.user = user_info
                st.session_state.id_token = user_info["idToken"]
                st.session_state.login_password = password  # Store for workflow
                st.success("Login successful!")
                st.session_state.stage = "navigator"
                st.rerun()
            else:
                st.error(resp.json().get("detail", "Login failed."))
    with tab2:
        signup_username = st.text_input("Username", key="signup_username")
        signup_email = st.text_input("Email", key="signup_email")
        signup_password = st.text_input("Password", type="password", key="signup_password")
        signup_role = st.selectbox("Role", ["user", "admin"])
        if st.button("Sign Up"):
            payload = {
                "email": signup_email,
                "password": signup_password,
                "role": signup_role,
                "username": signup_username
            }
            resp = requests.post(SIGNUP_URL, json=payload)
            if resp.ok:
                st.success("Signup successful! Please log in.")
            else:
                st.error(resp.json().get("detail", "Signup failed."))

# --- DASHBOARD 2: NAVIGATOR ---
elif st.session_state.stage == "navigator":
    st.header("Navigator")
    doc_type = st.selectbox("Document Type", ["claim", "policy", "report", "ID Proof", "Payment Receipt"])
    action = st.selectbox("Action", ["Upload", "Review"]) if st.session_state.user.get("role") == "admin" else "Upload"
    if st.button("Proceed to Intake"):
        st.session_state.doc_type = doc_type
        st.session_state.action = action
        st.session_state.stage = "intake"
        st.rerun()

# --- DASHBOARD 3: INTAKE (File Upload + Preview) ---
elif st.session_state.stage == "intake":
    st.header("Document Intake")
    uploaded_file = st.file_uploader("Upload Document", type=["pdf", "jpg", "jpeg", "png", "txt", "docx"])
    if uploaded_file:
        files = {"files": (uploaded_file.name, uploaded_file.getbuffer())}
        data = {
            "document_type": st.session_state.doc_type,
            "username": st.session_state.user["username"]
        }
        headers = {"Authorization": f"Bearer {st.session_state.id_token}"}
        upload_resp = requests.post("http://localhost:8004/upload_document", files=files, data=data, headers=headers)
        if upload_resp.ok:
            preview = upload_resp.json()["previews"][0]
            st.session_state.uploaded_file_path = preview["file_path"]
            st.session_state.intake_document = {
                "file_path": preview["file_path"],
                "doc_type": st.session_state.doc_type,
                "metadata": {
                    "username": st.session_state.user["username"],
                    "document_type": st.session_state.doc_type
                }
            }
            st.success(f"File uploaded: {uploaded_file.name}")
            if uploaded_file.type.startswith("image"):
                img = Image.open(uploaded_file)
                st.image(img, caption="Preview of uploaded document", use_container_width=True)
        else:
            st.error(f"Upload error: {upload_resp.status_code} - {upload_resp.text}")

    if st.button("Start Workflow"):
        if not st.session_state.get("intake_document"):
            st.error("Please upload a document and wait for upload to complete.")
        else:
            payload = {
                "user_credentials": {
                    "identifier": st.session_state.user["username"],
                    "password": st.session_state.get("login_password", "")
                },
                "doc_type": st.session_state.doc_type,
                "action": st.session_state.action,
                "document": st.session_state.intake_document
            }
            headers = {"Authorization": f"Bearer {st.session_state.id_token}"}
            with st.spinner("Running workflow..."):
                resp = requests.post(ORCHESTRATOR_URL, json=payload, headers=headers)
                if resp.ok:
                    st.session_state.workflow_result = resp.json()["result"]
                    st.session_state.stage = "workflow"
                    if "login_password" in st.session_state:
                        del st.session_state["login_password"]
                    st.rerun()
                else:
                    st.error(f"Error: {resp.status_code} - {resp.text}")

# --- DASHBOARD 4: WORKFLOW PROGRESS & RESULTS ---
elif st.session_state.stage == "workflow":
    st.header("Document Processing Progress")
    steps = ["Preprocessing", "Extracting", "Validating", "Syncing"]
    for step in steps:
        st.info(step)
    st.success("Workflow complete! See results below.")
    result = st.session_state.workflow_result
    st.subheader("Validation Result")
    st.json(result.get("validation_result", {}))
    st.subheader("Notification")
    st.info(result.get("notification", {}).get("message", "No notification."))
    if st.button("View Feedback"):
        st.session_state.stage = "feedback"
        st.rerun()

# --- DASHBOARD 5: FEEDBACK ---
elif st.session_state.stage == "feedback":
    st.header("Feedback")
    result = st.session_state.workflow_result
    val = result.get("validation_result", {})
    if not val.get("valid", True):
        st.warning(val.get("reason", "Validation failed."))
    st.subheader("Submit Feedback")
    issue_text = st.text_area("Describe your issue or feedback")
    rating = st.slider("Rating", 1, 5, 3)
    if st.button("Submit Feedback"):
        feedback_payload = {
            "username": st.session_state.user["username"],
            "issue_text": issue_text,
            "rating": rating
        }
        headers = {"Authorization": f"Bearer {st.session_state.id_token}"}
        feedback_resp = requests.post("http://localhost:8006/submit-feedback", json=feedback_payload, headers=headers)
        if feedback_resp.ok:
            st.success("Feedback submitted!")
            st.json(feedback_resp.json())
        else:
            st.error(feedback_resp.json().get("detail", "Feedback error."))
    if st.button("Restart Workflow"):
        st.session_state.stage = "navigator"
        st.session_state.workflow_result = None
        st.rerun()

# --- ADMIN REVIEW (Optional) ---
if st.session_state.user and st.session_state.user.get("role") == "admin":
    st.sidebar.markdown("---")
    if st.sidebar.button("Admin Review (View Synced Data)"):
        st.session_state.stage = "admin_review"
        st.rerun()

if st.session_state.stage == "admin_review":
    st.header("Admin Review: Synced Data")
    headers = {"Authorization": f"Bearer {st.session_state.id_token}"}
    try:
        resp = requests.get("http://localhost:8003/view_data", headers=headers)
        if resp.ok:
            st.json(resp.json())
        else:
            st.warning("No synced data found or SyncAgent not running.")
    except Exception as e:
        st.error(f"Error fetching synced data: {e}")
    if st.button("Back to Workflow"):
        st.session_state.stage = "workflow"
        st.rerun()

# --- FOOTER ---
st.markdown("""
---
<small>
Built with ðŸ¦™ Streamlit â€¢ Multi-Agent AI Orchestration â€¢ HuggingFace â€¢ ChromaDB â€¢ Firebase Auth
</small>
""", unsafe_allow_html=True)








